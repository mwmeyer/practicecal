<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>üóìÔ∏èPracticeCal</title>

        <!-- React -->
        <script
            crossorigin
            src="https://unpkg.com/react@18/umd/react.development.js"
        ></script>
        <script
            crossorigin
            src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
        ></script>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

        <!-- External CSS -->
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <div id="root"></div>

        <script type="text/babel">
            const { useState, useEffect } = React;

            // GraphQL client
            const gql = (strings, ...values) => {
                let result = strings[0];
                for (let i = 1; i < strings.length; i++) {
                    result += values[i - 1] + strings[i];
                }
                return result;
            };

            const useQuery = (query, options = {}) => {
                const [data, setData] = useState(null);
                const [loading, setLoading] = useState(!options.skip);
                const [error, setError] = useState(null);

                const executeQuery = async () => {
                    if (options.skip) return;
                    setLoading(true);
                    try {
                        const response = await fetch("/graphql", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                query,
                                variables: options.variables || {},
                            }),
                        });
                        const result = await response.json();
                        if (result.errors) {
                            throw new Error(result.errors[0].message);
                        }
                        setData(result);
                        setError(null);
                    } catch (err) {
                        setError(err);
                        setData(null);
                    }
                    setLoading(false);
                };

                useEffect(() => {
                    executeQuery();
                }, [query, JSON.stringify(options.variables), options.skip]);

                return { data, loading, error, refetch: executeQuery };
            };

            const useMutation = (mutation) => {
                const [loading, setLoading] = useState(false);

                const executeMutation = async (options = {}) => {
                    setLoading(true);
                    try {
                        const response = await fetch("/graphql", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                query: mutation,
                                variables: options.variables || {},
                            }),
                        });
                        const result = await response.json();
                        if (result.errors) {
                            throw new Error(result.errors[0].message);
                        }
                        return result;
                    } catch (err) {
                        throw err;
                    } finally {
                        setLoading(false);
                    }
                };

                return [executeMutation, { loading }];
            };

            // GraphQL queries
            const GET_CURRENT_WEEK = gql`
                query {
                    currentWeekStart
                }
            `;

            const GET_PRACTICE_SESSIONS_BY_DAY = gql`
                query ($weekStart: String!) {
                    practiceSessionsByDay(weekStart: $weekStart) {
                        date
                        dayName
                        totalMinutes
                        sessions {
                            id
                            durationMinutes
                            mediaData
                            mimeType
                        }
                    }
                }
            `;

            const GET_WEEKLY_PRACTICE = gql`
                query ($weekStart: String!) {
                    practiceSessionsForWeek(weekStart: $weekStart) {
                        totalMinutes
                    }
                }
            `;

            const CREATE_PRACTICE_SESSION = gql`
                mutation ($input: CreatePracticeSessionInput!) {
                    createPracticeSession(input: $input) {
                        id
                        mediaData
                        mimeType
                    }
                }
            `;

            const UPDATE_PRACTICE_SESSION = gql`
                mutation ($input: UpdatePracticeSessionInput!) {
                    updatePracticeSession(input: $input) {
                        id
                        mediaData
                        mimeType
                    }
                }
            `;

            const DELETE_PRACTICE_SESSION = gql`
                mutation ($id: Int!) {
                    deletePracticeSession(id: $id)
                }
            `;

            // Utilities
            const formatDate = (dateStr) => {
                const date = new Date(dateStr);
                return date.getDate();
            };

            const formatWeekRange = (weekStart) => {
                const start = new Date(weekStart);
                const end = new Date(start);
                end.setDate(start.getDate() + 6);

                const options = { month: "short", day: "numeric" };
                return `${start.toLocaleDateString("en-US", options)} ‚Äì ${end.toLocaleDateString("en-US", options)}`;
            };

            const isToday = (dateStr) => {
                return dateStr === new Date().toISOString().split("T")[0];
            };

            const addWeeks = (dateStr, weeks) => {
                const date = new Date(dateStr);
                date.setDate(date.getDate() + weeks * 7);
                return date.toISOString().split("T")[0];
            };

            const formatMinutes = (minutes) => {
                if (minutes < 60) return `${minutes}m`;
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            };

            // Helper function to convert blob to base64
            const blobToBase64 = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = reader.result;
                        console.log("FileReader result:", result);
                        const base64 = result.split(",")[1];
                        console.log("Extracted base64 length:", base64.length);
                        resolve(base64);
                    };
                    reader.onerror = (error) => {
                        console.error("FileReader error:", error);
                        reject(error);
                    };
                    reader.readAsDataURL(blob);
                });
            };

            // Modal Component
            function Modal({ isOpen, onClose, date, session, onSave }) {
                const [duration, setDuration] = useState("");
                const [isRecording, setIsRecording] = useState(false);
                const [recordingTime, setRecordingTime] = useState(0);
                const [mediaRecorder, setMediaRecorder] = useState(null);
                const [recordingStartTime, setRecordingStartTime] =
                    useState(null);
                const [audioBlob, setAudioBlob] = useState(null);
                const [audioUrl, setAudioUrl] = useState(null);

                const [mediaMimeType, setMediaMimeType] = useState(null);
                const [cameraEnabled, setCameraEnabled] = useState(true);

                const [createSession] = useMutation(CREATE_PRACTICE_SESSION);
                const [updateSession] = useMutation(UPDATE_PRACTICE_SESSION);
                const [deleteSession] = useMutation(DELETE_PRACTICE_SESSION);

                useEffect(() => {
                    if (session) {
                        setDuration(session.durationMinutes.toString());

                        // Handle existing audio data
                        if (session.mediaData) {
                            try {
                                console.log("Loading existing audio data", {
                                    dataLength: session.mediaData.length,
                                    mimeType: session.mimeType,
                                });

                                // Use a simpler approach to convert base64 to blob
                                const mimeType =
                                    session.mimeType || "audio/webm";

                                // Create blob directly from base64 using fetch
                                const dataUrl = `data:${mimeType};base64,${session.mediaData}`;

                                fetch(dataUrl)
                                    .then((res) => res.blob())
                                    .then((blob) => {
                                        console.log(
                                            "Created blob from fetch:",
                                            {
                                                size: blob.size,
                                                type: blob.type,
                                            },
                                        );

                                        const url = URL.createObjectURL(blob);
                                        setAudioBlob(blob);
                                        setAudioUrl(url);
                                        setMediaMimeType(mimeType);

                                        console.log(
                                            "Set audio URL for existing session:",
                                            url,
                                        );
                                    })
                                    .catch((error) => {
                                        console.error(
                                            "Error creating blob from fetch:",
                                            error,
                                        );
                                        setAudioBlob(null);
                                        setAudioUrl(null);
                                        setMediaMimeType(null);
                                    });
                            } catch (error) {
                                console.error(
                                    "Error loading audio data:",
                                    error,
                                );
                                setAudioBlob(null);
                                setAudioUrl(null);
                                setMediaMimeType(null);
                                alert(
                                    "Could not load existing audio recording",
                                );
                            }
                        } else {
                            setAudioBlob(null);
                            setAudioUrl(null);
                        }
                    } else {
                        setDuration("");
                        setIsRecording(false);
                        setRecordingTime(0);
                        setAudioBlob(null);
                        setAudioUrl(null);
                        setMediaMimeType(null);
                    }
                }, [session, isOpen]);

                // Clean up audio URL when component unmounts or changes
                useEffect(() => {
                    return () => {
                        if (audioUrl) {
                            URL.revokeObjectURL(audioUrl);
                        }
                    };
                }, [audioUrl]);

                // Timer effect for recording
                useEffect(() => {
                    let interval = null;
                    if (isRecording && recordingStartTime) {
                        interval = setInterval(() => {
                            const elapsed = Math.floor(
                                (Date.now() - recordingStartTime) / 1000,
                            );
                            setRecordingTime(elapsed);
                        }, 1000);
                    }
                    return () => {
                        if (interval) clearInterval(interval);
                    };
                }, [isRecording, recordingStartTime]);

                const startRecording = async () => {
                    try {
                        const constraints = {
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true,
                            },
                        };

                        if (cameraEnabled) {
                            constraints.video = {
                                width: { ideal: 1280 },
                                height: { ideal: 720 },
                                frameRate: { ideal: 30 },
                            };
                        }

                        const stream =
                            await navigator.mediaDevices.getUserMedia(
                                constraints,
                            );
                        // Choose the best supported MIME type - prefer video formats
                        let mimeType = cameraEnabled
                            ? "video/webm"
                            : "audio/webm";

                        console.log("Codec support check:", {
                            cameraEnabled,
                            "video/webm":
                                MediaRecorder.isTypeSupported("video/webm"),
                            "video/mp4":
                                MediaRecorder.isTypeSupported("video/mp4"),
                            "video/webm;codecs=vp8":
                                MediaRecorder.isTypeSupported(
                                    "video/webm;codecs=vp8",
                                ),
                            "video/webm;codecs=vp9":
                                MediaRecorder.isTypeSupported(
                                    "video/webm;codecs=vp9",
                                ),
                            "audio/webm":
                                MediaRecorder.isTypeSupported("audio/webm"),
                            "audio/mp4":
                                MediaRecorder.isTypeSupported("audio/mp4"),
                        });

                        if (cameraEnabled) {
                            // Prioritize MP4 for better compatibility
                            if (MediaRecorder.isTypeSupported("video/mp4")) {
                                mimeType = "video/mp4";
                            } else if (
                                MediaRecorder.isTypeSupported("video/webm")
                            ) {
                                mimeType = "video/webm";
                            }
                        } else {
                            if (
                                MediaRecorder.isTypeSupported(
                                    "audio/webm;codecs=opus",
                                )
                            ) {
                                mimeType = "audio/webm;codecs=opus";
                            } else if (
                                MediaRecorder.isTypeSupported("audio/webm")
                            ) {
                                mimeType = "audio/webm";
                            } else if (
                                MediaRecorder.isTypeSupported("audio/mp4")
                            ) {
                                mimeType = "audio/mp4";
                            }
                        }

                        console.log("Creating MediaRecorder with:", {
                            mimeType,
                            streamTracks: stream.getTracks().map((track) => ({
                                kind: track.kind,
                                label: track.label,
                                enabled: track.enabled,
                            })),
                        });

                        // Ensure we have the expected tracks
                        const audioTracks = stream.getAudioTracks();
                        const videoTracks = stream.getVideoTracks();

                        console.log("Stream tracks:", {
                            audioTracks: audioTracks.length,
                            videoTracks: videoTracks.length,
                            cameraEnabled,
                        });

                        if (audioTracks.length === 0) {
                            throw new Error("No audio track available");
                        }

                        if (cameraEnabled && videoTracks.length === 0) {
                            console.warn(
                                "Video requested but no video track available",
                            );
                        }

                        const recorder = new MediaRecorder(stream, {
                            mimeType,
                        });

                        const audioChunks = [];
                        recorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        recorder.onstop = () => {
                            console.log(
                                "Recording stopped, audio chunks:",
                                audioChunks.length,
                            );

                            if (audioChunks.length === 0) {
                                console.error("No audio data recorded");
                                alert("No audio data was recorded");
                                return;
                            }

                            const blob = new Blob(audioChunks, {
                                type: mimeType,
                            });

                            console.log("Created media blob:", {
                                size: blob.size,
                                type: blob.type,
                                mimeType,
                                chunks: audioChunks.length,
                                firstChunkSize: audioChunks[0]?.size,
                            });

                            const url = URL.createObjectURL(blob);
                            setAudioBlob(blob);
                            setAudioUrl(url);
                            setMediaMimeType(mimeType);

                            console.log("Audio blob URL created:", url);
                        };

                        setMediaRecorder(recorder);
                        setRecordingStartTime(Date.now());
                        setIsRecording(true);
                        recorder.start();
                    } catch (error) {
                        console.error("Error starting recording:", error);
                        alert(
                            "Could not access microphone. Please check permissions.",
                        );
                    }
                };

                const stopRecording = () => {
                    if (mediaRecorder && isRecording) {
                        mediaRecorder.stop();
                        mediaRecorder.stream
                            .getTracks()
                            .forEach((track) => track.stop());
                        setIsRecording(false);

                        // Set duration from recording time (convert seconds to minutes, rounded up)
                        const minutes = Math.max(
                            1,
                            Math.ceil(recordingTime / 60),
                        );
                        setDuration(minutes.toString());
                    }
                };

                const formatRecordingTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, "0")}`;
                };

                const MediaPlayer = ({ mediaBlob, mimeType, onError }) => {
                    const [currentTime, setCurrentTime] = React.useState(0);
                    const [duration, setDuration] = React.useState(0);
                    const [volume, setVolume] = React.useState(1);
                    const [isMuted, setIsMuted] = React.useState(false);
                    const [isPlaying, setIsPlaying] = React.useState(false);
                    const [mediaElement, setMediaElement] =
                        React.useState(null);
                    const [mediaUrl, setMediaUrl] = React.useState(null);
                    const [hasError, setHasError] = React.useState(false);
                    const playerRef = React.useRef(null);

                    React.useEffect(() => {
                        if (!mediaBlob) return;

                        const url = URL.createObjectURL(mediaBlob);
                        setMediaUrl(url);
                        setHasError(false);

                        const isVideo =
                            mimeType && mimeType.startsWith("video/");
                        let media;

                        if (isVideo) {
                            media = document.createElement("video");
                            media.style.width = "100%";
                            media.style.maxHeight = "300px";
                            media.style.borderRadius = "8px 8px 0 0";
                            media.style.backgroundColor = "#000";
                        } else {
                            media = new Audio();
                        }

                        media.src = url;
                        media.preload = "metadata";

                        media.onloadedmetadata = () => {
                            setDuration(media.duration);
                            setCurrentTime(0);
                        };

                        media.ontimeupdate = () => {
                            setCurrentTime(media.currentTime);
                        };

                        media.onended = () => {
                            setIsPlaying(false);
                            setCurrentTime(0);
                        };

                        media.onerror = () => {
                            setHasError(true);
                            setIsPlaying(false);
                            if (onError) onError();
                        };

                        media.onvolumechange = () => {
                            setVolume(media.volume);
                            setIsMuted(media.muted);
                        };

                        setMediaElement(media);

                        if (isVideo && playerRef.current) {
                            const videoContainer =
                                playerRef.current.querySelector(
                                    ".video-container",
                                );
                            if (videoContainer) {
                                videoContainer.innerHTML = "";
                                videoContainer.appendChild(media);
                            }
                        }

                        return () => {
                            URL.revokeObjectURL(url);
                        };
                    }, [mediaBlob, mimeType]);

                    const togglePlay = () => {
                        if (!mediaElement) return;

                        if (isPlaying) {
                            mediaElement.pause();
                            setIsPlaying(false);
                        } else {
                            mediaElement
                                .play()
                                .then(() => {
                                    setIsPlaying(true);
                                })
                                .catch((error) => {
                                    console.error("Play error:", error);
                                    setHasError(true);
                                    if (onError) onError();
                                });
                        }
                    };

                    const handleSeek = (e) => {
                        if (!mediaElement || !duration) return;
                        const rect = e.target.getBoundingClientRect();
                        const percent = (e.clientX - rect.left) / rect.width;
                        const newTime = percent * duration;
                        mediaElement.currentTime = newTime;
                        setCurrentTime(newTime);
                    };

                    const handleVolumeChange = (e) => {
                        if (!mediaElement) return;
                        const newVolume = parseFloat(e.target.value);
                        mediaElement.volume = newVolume;
                        setVolume(newVolume);
                    };

                    const toggleMute = () => {
                        if (!mediaElement) return;
                        mediaElement.muted = !mediaElement.muted;
                        setIsMuted(mediaElement.muted);
                    };

                    const handleDownload = () => {
                        if (!mediaBlob) return;

                        const isVideo =
                            mimeType && mimeType.startsWith("video/");
                        const extension = isVideo ? ".webm" : ".webm";
                        const filename = `practice-recording-${new Date().toISOString().slice(0, 19).replace(/:/g, "-")}${extension}`;

                        const url = URL.createObjectURL(mediaBlob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    };

                    const formatTime = (time) => {
                        const minutes = Math.floor(time / 60);
                        const seconds = Math.floor(time % 60);
                        return `${minutes}:${seconds.toString().padStart(2, "0")}`;
                    };

                    if (hasError) {
                        return (
                            <div className="media-player error">
                                <div className="error-message">
                                    ‚ö†Ô∏è Unable to play media
                                    <button
                                        onClick={handleDownload}
                                        className="download-fallback"
                                    >
                                        üíæ Download to play externally
                                    </button>
                                </div>
                            </div>
                        );
                    }

                    const isVideo = mimeType && mimeType.startsWith("video/");

                    return (
                        <div className="media-player" ref={playerRef}>
                            {isVideo && <div className="video-container"></div>}
                            {!isVideo && (
                                <div className="audio-visualizer">
                                    üéµ Audio Recording
                                </div>
                            )}
                            <div className="player-controls">
                                <div className="control-row">
                                    <button
                                        className="play-pause-btn"
                                        onClick={togglePlay}
                                        disabled={!mediaElement}
                                    >
                                        {isPlaying ? "‚è∏Ô∏è" : "‚ñ∂Ô∏è"}
                                    </button>
                                    <div className="progress-container">
                                        <div
                                            className="progress-bar"
                                            onClick={handleSeek}
                                        >
                                            <div
                                                className="progress-filled"
                                                style={{
                                                    width: `${(currentTime / duration) * 100}%`,
                                                }}
                                            ></div>
                                        </div>
                                        <div className="time-display">
                                            {formatTime(currentTime)} /{" "}
                                            {formatTime(duration)}
                                        </div>
                                    </div>
                                    <div className="volume-controls">
                                        <button
                                            className="mute-btn"
                                            onClick={toggleMute}
                                        >
                                            {isMuted ? "üîá" : "üîä"}
                                        </button>
                                        <input
                                            type="range"
                                            min="0"
                                            max="1"
                                            step="0.1"
                                            value={isMuted ? 0 : volume}
                                            onChange={handleVolumeChange}
                                            className="volume-slider"
                                        />
                                    </div>
                                    <button
                                        className="download-btn"
                                        onClick={handleDownload}
                                        title="Download recording"
                                    >
                                        üíæ
                                    </button>
                                </div>
                            </div>
                        </div>
                    );
                };

                const handleSave = async () => {
                    const finalDuration = Math.max(
                        1,
                        Math.ceil(recordingTime / 60),
                    );

                    if (!finalDuration || finalDuration <= 0) return;

                    try {
                        let mediaData = null;
                        let mimeType = null;
                        if (audioBlob) {
                            console.log("Converting audio blob to base64:", {
                                blobSize: audioBlob.size,
                                blobType: audioBlob.type,
                            });
                            mediaData = await blobToBase64(audioBlob);
                            mimeType = mediaMimeType;
                            console.log(
                                "Audio data converted, size:",
                                mediaData.length,
                            );
                        }

                        if (session) {
                            await updateSession({
                                variables: {
                                    input: {
                                        id: session.id,
                                        durationMinutes: finalDuration,
                                        mediaData: mediaData,
                                        mimeType: mimeType,
                                    },
                                },
                            });
                        } else {
                            await createSession({
                                variables: {
                                    input: {
                                        date,
                                        durationMinutes: finalDuration,
                                        mediaData: mediaData,
                                        mimeType: mimeType,
                                    },
                                },
                            });
                        }
                        onSave();
                        onClose();
                    } catch (error) {
                        console.error(error);
                    }
                };

                const handleDelete = async () => {
                    if (!session) return;
                    try {
                        await deleteSession({ variables: { id: session.id } });
                        onSave();
                        onClose();
                    } catch (error) {
                        console.error(error);
                    }
                };

                if (!isOpen) return null;

                return (
                    <div className="modal">
                        <div className="modal-content">
                            <h3 className="modal-title">
                                {session ? "Edit Practice" : "Add Practice"}
                            </h3>

                            {!session ? (
                                <div className="form-group">
                                    <div className="camera-toggle">
                                        <label className="form-label">
                                            <input
                                                type="checkbox"
                                                checked={cameraEnabled}
                                                onChange={(e) =>
                                                    setCameraEnabled(
                                                        e.target.checked,
                                                    )
                                                }
                                                disabled={isRecording}
                                            />
                                            üìπ Record Video (uncheck for
                                            audio-only)
                                        </label>
                                    </div>
                                    <div className="recording-controls">
                                        {!isRecording ? (
                                            <button
                                                type="button"
                                                className="record-button start"
                                                onClick={startRecording}
                                            >
                                                ‚ñ∂Ô∏è Start Recording
                                            </button>
                                        ) : (
                                            <>
                                                <div className="recording-timer">
                                                    üî¥{" "}
                                                    {formatRecordingTime(
                                                        recordingTime,
                                                    )}
                                                </div>
                                                <button
                                                    type="button"
                                                    className="record-button stop"
                                                    onClick={stopRecording}
                                                >
                                                    ‚èπÔ∏è Stop Recording
                                                </button>
                                            </>
                                        )}
                                    </div>
                                    {recordingTime > 0 && !isRecording && (
                                        <div className="recording-result">
                                            <div className="recording-info">
                                                Recorded:{" "}
                                                {formatRecordingTime(
                                                    recordingTime,
                                                )}
                                                (
                                                {Math.max(
                                                    1,
                                                    Math.ceil(
                                                        recordingTime / 60,
                                                    ),
                                                )}{" "}
                                                minutes)
                                            </div>
                                            {audioBlob && (
                                                <MediaPlayer
                                                    mediaBlob={audioBlob}
                                                    mimeType={mediaMimeType}
                                                    onError={() => {
                                                        console.error(
                                                            "Media player error",
                                                        );
                                                    }}
                                                />
                                            )}
                                        </div>
                                    )}
                                </div>
                            ) : null}

                            {session && session.mediaData && audioBlob && (
                                <div className="form-group">
                                    <label className="form-label">
                                        Recorded Media
                                    </label>
                                    <MediaPlayer
                                        mediaBlob={audioBlob}
                                        mimeType={mediaMimeType}
                                        onError={() => {
                                            console.error(
                                                "Media player error for existing session",
                                            );
                                        }}
                                    />
                                </div>
                            )}

                            <div className="modal-actions">
                                <button
                                    className="button button-secondary"
                                    onClick={onClose}
                                    disabled={isRecording}
                                >
                                    Cancel
                                </button>
                                {session && (
                                    <button
                                        className="button button-danger"
                                        onClick={handleDelete}
                                        disabled={isRecording}
                                    >
                                        Delete
                                    </button>
                                )}
                                <button
                                    className="button button-primary"
                                    onClick={handleSave}
                                    disabled={
                                        isRecording || recordingTime === 0
                                    }
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            // Main App
            function App() {
                const [currentWeek, setCurrentWeek] = useState("");
                const [modalOpen, setModalOpen] = useState(false);
                const [modalDate, setModalDate] = useState("");
                const [modalSession, setModalSession] = useState(null);

                const { data: weekData, loading: weekLoading } =
                    useQuery(GET_CURRENT_WEEK);

                useEffect(() => {
                    if (weekData?.data?.currentWeekStart && !currentWeek) {
                        setCurrentWeek(weekData.data.currentWeekStart);
                    }
                }, [weekData, currentWeek]);

                const {
                    data: practiceData,
                    loading: practiceLoading,
                    refetch,
                } = useQuery(GET_PRACTICE_SESSIONS_BY_DAY, {
                    variables: { weekStart: currentWeek },
                    skip: !currentWeek,
                });

                const { data: weeklyData, refetch: refetchWeekly } = useQuery(
                    GET_WEEKLY_PRACTICE,
                    {
                        variables: { weekStart: currentWeek },
                        skip: !currentWeek,
                    },
                );

                const practiceByDay =
                    practiceData?.data?.practiceSessionsByDay || [];
                const weeklyTotal =
                    weeklyData?.data?.practiceSessionsForWeek?.totalMinutes ||
                    0;

                const handleDayClick = (date) => {
                    setModalDate(date);
                    setModalSession(null);
                    setModalOpen(true);
                };

                const handleSessionClick = (session, date, e) => {
                    e.stopPropagation();
                    setModalDate(date);
                    setModalSession(session);
                    setModalOpen(true);
                };

                const handleSave = () => {
                    refetch();
                    refetchWeekly();
                };

                if (weekLoading || practiceLoading) {
                    return <div className="loading">Loading...</div>;
                }

                return (
                    <div className="app">
                        <header className="header">
                            <h1 className="title">üóìÔ∏èPracticeCal</h1>
                        </header>

                        <div className="week-nav">
                            <button
                                className="nav-button"
                                onClick={() =>
                                    setCurrentWeek(addWeeks(currentWeek, -1))
                                }
                            >
                                ‚Äπ
                            </button>
                            <div className="week-title">
                                {formatWeekRange(currentWeek)}
                            </div>
                            <button
                                className="nav-button"
                                onClick={() =>
                                    setCurrentWeek(addWeeks(currentWeek, 1))
                                }
                            >
                                ‚Ä∫
                            </button>
                        </div>

                        <div className="calendar">
                            <div className="calendar-row">
                                <div className="day-header">Sun</div>
                                <div className="day-header">Mon</div>
                                <div className="day-header">Tue</div>
                                <div className="day-header">Wed</div>
                                <div className="day-header">Thu</div>
                                <div className="day-header">Fri</div>
                                <div className="day-header">Sat</div>
                            </div>
                            <div className="calendar-row">
                                {practiceByDay.map((day) => (
                                    <div
                                        key={day.date}
                                        className={`day-cell ${
                                            day.totalMinutes > 0
                                                ? "has-practice"
                                                : ""
                                        } ${isToday(day.date) ? "today" : ""}`}
                                        onClick={() => handleDayClick(day.date)}
                                    >
                                        <div className="day-date">
                                            {formatDate(day.date)}
                                        </div>
                                        {day.totalMinutes > 0 && (
                                            <div className="day-total">
                                                {formatMinutes(
                                                    day.totalMinutes,
                                                )}
                                            </div>
                                        )}
                                        {day.sessions.map((session) => (
                                            <div
                                                key={session.id}
                                                className="session"
                                                onClick={(e) =>
                                                    handleSessionClick(
                                                        session,
                                                        day.date,
                                                        e,
                                                    )
                                                }
                                            >
                                                <div className="session-duration">
                                                    {formatMinutes(
                                                        session.durationMinutes,
                                                    )}
                                                </div>
                                                {session.mediaData && (
                                                    <div className="session-audio-indicator">
                                                        üéôÔ∏è
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="total-practice">
                            <div className="total-label">
                                Total Practice Time
                            </div>
                            <div className="total-time">
                                {weeklyTotal > 0
                                    ? formatMinutes(weeklyTotal)
                                    : "0m"}
                            </div>
                            <div className="total-subtitle">This week</div>
                        </div>

                        <Modal
                            isOpen={modalOpen}
                            onClose={() => setModalOpen(false)}
                            date={modalDate}
                            session={modalSession}
                            onSave={handleSave}
                        />
                    </div>
                );
            }

            ReactDOM.createRoot(document.getElementById("root")).render(
                <App />,
            );
        </script>
    </body>
</html>
