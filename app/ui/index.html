<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>🗓️PracticeCal</title>

        <!-- React -->
        <script
            crossorigin
            src="https://unpkg.com/react@18/umd/react.development.js"
        ></script>
        <script
            crossorigin
            src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
        ></script>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

        <!-- External CSS -->
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <div id="root"></div>

        <script type="text/babel">
            const { useState, useEffect } = React;

            // GraphQL client
            const gql = (strings, ...values) => {
                let result = strings[0];
                for (let i = 1; i < strings.length; i++) {
                    result += values[i - 1] + strings[i];
                }
                return result;
            };

            const useQuery = (query, options = {}) => {
                const [data, setData] = useState(null);
                const [loading, setLoading] = useState(!options.skip);
                const [error, setError] = useState(null);

                const executeQuery = async () => {
                    if (options.skip) return;
                    setLoading(true);
                    try {
                        const response = await fetch("/graphql", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                query,
                                variables: options.variables || {},
                            }),
                        });
                        const result = await response.json();
                        if (result.errors) {
                            throw new Error(result.errors[0].message);
                        }
                        setData(result);
                        setError(null);
                    } catch (err) {
                        setError(err);
                        setData(null);
                    }
                    setLoading(false);
                };

                useEffect(() => {
                    executeQuery();
                }, [query, JSON.stringify(options.variables), options.skip]);

                return { data, loading, error, refetch: executeQuery };
            };

            const useMutation = (mutation) => {
                const [loading, setLoading] = useState(false);

                const executeMutation = async (options = {}) => {
                    setLoading(true);
                    try {
                        const response = await fetch("/graphql", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                query: mutation,
                                variables: options.variables || {},
                            }),
                        });
                        const result = await response.json();
                        if (result.errors) {
                            throw new Error(result.errors[0].message);
                        }
                        return result;
                    } catch (err) {
                        throw err;
                    } finally {
                        setLoading(false);
                    }
                };

                return [executeMutation, { loading }];
            };

            // GraphQL queries
            const GET_CURRENT_WEEK = gql`
                query {
                    currentWeekStart
                }
            `;

            const GET_PRACTICE_SESSIONS_BY_DAY = gql`
                query ($weekStart: String!) {
                    practiceSessionsByDay(weekStart: $weekStart) {
                        date
                        dayName
                        totalMinutes
                        sessions {
                            id
                            durationMinutes
                            audioData
                            mimeType
                        }
                    }
                }
            `;

            const GET_WEEKLY_PRACTICE = gql`
                query ($weekStart: String!) {
                    practiceSessionsForWeek(weekStart: $weekStart) {
                        totalMinutes
                    }
                }
            `;

            const CREATE_PRACTICE_SESSION = gql`
                mutation ($input: CreatePracticeSessionInput!) {
                    createPracticeSession(input: $input) {
                        id
                        audioData
                        mimeType
                    }
                }
            `;

            const UPDATE_PRACTICE_SESSION = gql`
                mutation ($input: UpdatePracticeSessionInput!) {
                    updatePracticeSession(input: $input) {
                        id
                        audioData
                        mimeType
                    }
                }
            `;

            const DELETE_PRACTICE_SESSION = gql`
                mutation ($id: Int!) {
                    deletePracticeSession(id: $id)
                }
            `;

            // Utilities
            const formatDate = (dateStr) => {
                const date = new Date(dateStr);
                return date.getDate();
            };

            const formatWeekRange = (weekStart) => {
                const start = new Date(weekStart);
                const end = new Date(start);
                end.setDate(start.getDate() + 6);

                const options = { month: "short", day: "numeric" };
                return `${start.toLocaleDateString("en-US", options)} – ${end.toLocaleDateString("en-US", options)}`;
            };

            const isToday = (dateStr) => {
                return dateStr === new Date().toISOString().split("T")[0];
            };

            const addWeeks = (dateStr, weeks) => {
                const date = new Date(dateStr);
                date.setDate(date.getDate() + weeks * 7);
                return date.toISOString().split("T")[0];
            };

            const formatMinutes = (minutes) => {
                if (minutes < 60) return `${minutes}m`;
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            };

            // Helper function to convert blob to base64
            const blobToBase64 = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = reader.result;
                        console.log("FileReader result:", result);
                        const base64 = result.split(",")[1];
                        console.log("Extracted base64 length:", base64.length);
                        resolve(base64);
                    };
                    reader.onerror = (error) => {
                        console.error("FileReader error:", error);
                        reject(error);
                    };
                    reader.readAsDataURL(blob);
                });
            };

            // Modal Component
            function Modal({ isOpen, onClose, date, session, onSave }) {
                const [mode, setMode] = useState("manual"); // "manual" or "record"
                const [duration, setDuration] = useState("");
                const [isRecording, setIsRecording] = useState(false);
                const [recordingTime, setRecordingTime] = useState(0);
                const [mediaRecorder, setMediaRecorder] = useState(null);
                const [recordingStartTime, setRecordingStartTime] =
                    useState(null);
                const [audioBlob, setAudioBlob] = useState(null);
                const [audioUrl, setAudioUrl] = useState(null);
                const [isPlaying, setIsPlaying] = useState(false);
                const [audioElement, setAudioElement] = useState(null);
                const [audioMimeType, setAudioMimeType] = useState(null);

                const [createSession] = useMutation(CREATE_PRACTICE_SESSION);
                const [updateSession] = useMutation(UPDATE_PRACTICE_SESSION);
                const [deleteSession] = useMutation(DELETE_PRACTICE_SESSION);

                useEffect(() => {
                    if (session) {
                        setDuration(session.durationMinutes.toString());
                        setMode("manual");

                        // Handle existing audio data
                        if (session.audioData) {
                            try {
                                console.log("Loading existing audio data", {
                                    dataLength: session.audioData.length,
                                    mimeType: session.mimeType,
                                });

                                // Use a simpler approach to convert base64 to blob
                                const mimeType =
                                    session.mimeType || "audio/webm";

                                // Create blob directly from base64 using fetch
                                const dataUrl = `data:${mimeType};base64,${session.audioData}`;

                                fetch(dataUrl)
                                    .then((res) => res.blob())
                                    .then((blob) => {
                                        console.log(
                                            "Created blob from fetch:",
                                            {
                                                size: blob.size,
                                                type: blob.type,
                                            },
                                        );

                                        const url = URL.createObjectURL(blob);
                                        setAudioBlob(blob);
                                        setAudioUrl(url);
                                        setAudioMimeType(mimeType);

                                        console.log(
                                            "Set audio URL for existing session:",
                                            url,
                                        );
                                    })
                                    .catch((error) => {
                                        console.error(
                                            "Error creating blob from fetch:",
                                            error,
                                        );
                                        setAudioBlob(null);
                                        setAudioUrl(null);
                                        setAudioMimeType(null);
                                    });
                            } catch (error) {
                                console.error(
                                    "Error loading audio data:",
                                    error,
                                );
                                setAudioBlob(null);
                                setAudioUrl(null);
                                setAudioMimeType(null);
                                alert(
                                    "Could not load existing audio recording",
                                );
                            }
                        } else {
                            setAudioBlob(null);
                            setAudioUrl(null);
                        }
                    } else {
                        setDuration("");
                        setMode("manual");
                        setIsRecording(false);
                        setRecordingTime(0);
                        setAudioBlob(null);
                        setAudioUrl(null);
                        setIsPlaying(false);
                        setAudioMimeType(null);
                    }
                }, [session, isOpen]);

                // Clean up audio URL when component unmounts or changes
                useEffect(() => {
                    return () => {
                        if (audioUrl) {
                            URL.revokeObjectURL(audioUrl);
                        }
                        if (audioElement) {
                            audioElement.pause();
                            audioElement.currentTime = 0;
                        }
                    };
                }, [audioUrl, audioElement]);

                // Timer effect for recording
                useEffect(() => {
                    let interval = null;
                    if (isRecording && recordingStartTime) {
                        interval = setInterval(() => {
                            const elapsed = Math.floor(
                                (Date.now() - recordingStartTime) / 1000,
                            );
                            setRecordingTime(elapsed);
                        }, 1000);
                    }
                    return () => {
                        if (interval) clearInterval(interval);
                    };
                }, [isRecording, recordingStartTime]);

                const startRecording = async () => {
                    try {
                        const stream =
                            await navigator.mediaDevices.getUserMedia({
                                audio: true,
                            });
                        // Choose the best supported MIME type
                        let mimeType = "audio/webm";
                        if (
                            MediaRecorder.isTypeSupported(
                                "audio/webm;codecs=opus",
                            )
                        ) {
                            mimeType = "audio/webm;codecs=opus";
                        } else if (MediaRecorder.isTypeSupported("audio/mp4")) {
                            mimeType = "audio/mp4";
                        } else if (
                            MediaRecorder.isTypeSupported(
                                "audio/ogg;codecs=opus",
                            )
                        ) {
                            mimeType = "audio/ogg;codecs=opus";
                        }

                        const recorder = new MediaRecorder(stream, {
                            mimeType,
                        });

                        const audioChunks = [];
                        recorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        recorder.onstop = () => {
                            console.log(
                                "Recording stopped, audio chunks:",
                                audioChunks.length,
                            );

                            if (audioChunks.length === 0) {
                                console.error("No audio data recorded");
                                alert("No audio data was recorded");
                                return;
                            }

                            const blob = new Blob(audioChunks, {
                                type: mimeType,
                            });

                            console.log("Created audio blob:", {
                                size: blob.size,
                                type: blob.type,
                                mimeType,
                            });

                            const url = URL.createObjectURL(blob);
                            setAudioBlob(blob);
                            setAudioUrl(url);
                            setAudioMimeType(mimeType);

                            console.log("Audio blob URL created:", url);
                        };

                        setMediaRecorder(recorder);
                        setRecordingStartTime(Date.now());
                        setIsRecording(true);
                        recorder.start();
                    } catch (error) {
                        console.error("Error starting recording:", error);
                        alert(
                            "Could not access microphone. Please check permissions.",
                        );
                    }
                };

                const stopRecording = () => {
                    if (mediaRecorder && isRecording) {
                        mediaRecorder.stop();
                        mediaRecorder.stream
                            .getTracks()
                            .forEach((track) => track.stop());
                        setIsRecording(false);

                        // Set duration from recording time (convert seconds to minutes, rounded up)
                        const minutes = Math.max(
                            1,
                            Math.ceil(recordingTime / 60),
                        );
                        setDuration(minutes.toString());
                    }
                };

                const formatRecordingTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, "0")}`;
                };

                const playAudio = () => {
                    console.log("playAudio called", {
                        audioUrl,
                        audioBlob,
                        audioMimeType,
                    });

                    if (!audioBlob) {
                        console.error("No audio blob available");
                        alert("No audio data available");
                        return;
                    }

                    // Create a fresh URL each time to avoid stale references
                    if (audioUrl) {
                        URL.revokeObjectURL(audioUrl);
                    }

                    const freshUrl = URL.createObjectURL(audioBlob);
                    setAudioUrl(freshUrl);

                    console.log("Created fresh audio URL:", freshUrl);
                    console.log("Audio blob details:", {
                        size: audioBlob.size,
                        type: audioBlob.type,
                    });

                    const audio = new Audio(freshUrl);
                    setAudioElement(audio);
                    setIsPlaying(true);

                    audio.onended = () => {
                        setIsPlaying(false);
                        console.log("Audio playback ended");
                    };

                    audio.onerror = (e) => {
                        setIsPlaying(false);
                        console.error("Audio playback error:", e, audio.error);
                        alert(
                            `Error playing audio: ${audio.error ? audio.error.message : "Unknown error"}`,
                        );
                    };

                    audio.onloadstart = () => {
                        console.log("Audio loading started");
                    };

                    audio.oncanplay = () => {
                        console.log("Audio can play");
                        audio.play().catch((error) => {
                            setIsPlaying(false);
                            console.error("Audio play error:", error);
                            alert("Error starting audio playback");
                        });
                    };
                };

                const stopAudio = () => {
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.currentTime = 0;
                        setIsPlaying(false);
                    }
                };

                const handleSave = async () => {
                    const finalDuration =
                        mode === "record"
                            ? Math.max(1, Math.ceil(recordingTime / 60))
                            : parseInt(duration);

                    if (!finalDuration || finalDuration <= 0) return;

                    try {
                        let audioData = null;
                        let mimeType = null;
                        if (mode === "record" && audioBlob) {
                            console.log("Converting audio blob to base64:", {
                                blobSize: audioBlob.size,
                                blobType: audioBlob.type,
                            });
                            audioData = await blobToBase64(audioBlob);
                            mimeType = audioMimeType;
                            console.log(
                                "Audio data converted, size:",
                                audioData.length,
                            );
                        }

                        if (session) {
                            await updateSession({
                                variables: {
                                    input: {
                                        id: session.id,
                                        durationMinutes: finalDuration,
                                        audioData: audioData,
                                        mimeType: mimeType,
                                    },
                                },
                            });
                        } else {
                            await createSession({
                                variables: {
                                    input: {
                                        date,
                                        durationMinutes: finalDuration,
                                        audioData: audioData,
                                        mimeType: mimeType,
                                    },
                                },
                            });
                        }
                        onSave();
                        onClose();
                    } catch (error) {
                        console.error(error);
                    }
                };

                const handleDelete = async () => {
                    if (!session) return;
                    try {
                        await deleteSession({ variables: { id: session.id } });
                        onSave();
                        onClose();
                    } catch (error) {
                        console.error(error);
                    }
                };

                if (!isOpen) return null;

                return (
                    <div className="modal">
                        <div className="modal-content">
                            <h3 className="modal-title">
                                {session ? "Edit Practice" : "Add Practice"}
                            </h3>

                            {!session && (
                                <div className="form-group">
                                    <div className="mode-selector">
                                        <button
                                            type="button"
                                            className={`mode-button ${mode === "record" ? "active" : ""}`}
                                            onClick={() => setMode("record")}
                                            disabled={isRecording}
                                        >
                                            🎙️ Record
                                        </button>
                                        <button
                                            type="button"
                                            className={`mode-button ${mode === "manual" ? "active" : ""}`}
                                            onClick={() => setMode("manual")}
                                            disabled={isRecording}
                                        >
                                            ⏱️ Manual
                                        </button>
                                    </div>
                                </div>
                            )}

                            {mode === "record" && !session ? (
                                <div className="form-group">
                                    <div className="recording-controls">
                                        {!isRecording ? (
                                            <button
                                                type="button"
                                                className="record-button start"
                                                onClick={startRecording}
                                            >
                                                ▶️ Start Recording
                                            </button>
                                        ) : (
                                            <>
                                                <div className="recording-timer">
                                                    🔴{" "}
                                                    {formatRecordingTime(
                                                        recordingTime,
                                                    )}
                                                </div>
                                                <button
                                                    type="button"
                                                    className="record-button stop"
                                                    onClick={stopRecording}
                                                >
                                                    ⏹️ Stop Recording
                                                </button>
                                            </>
                                        )}
                                    </div>
                                    {recordingTime > 0 && !isRecording && (
                                        <div className="recording-result">
                                            <div className="recording-info">
                                                Recorded:{" "}
                                                {formatRecordingTime(
                                                    recordingTime,
                                                )}
                                                (
                                                {Math.max(
                                                    1,
                                                    Math.ceil(
                                                        recordingTime / 60,
                                                    ),
                                                )}{" "}
                                                minutes)
                                            </div>
                                            {audioUrl && (
                                                <div className="audio-controls">
                                                    {!isPlaying ? (
                                                        <button
                                                            type="button"
                                                            className="audio-button play"
                                                            onClick={playAudio}
                                                        >
                                                            ▶️ Play Recording
                                                        </button>
                                                    ) : (
                                                        <button
                                                            type="button"
                                                            className="audio-button stop"
                                                            onClick={stopAudio}
                                                        >
                                                            ⏸️ Stop Playback
                                                        </button>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            ) : (
                                <div className="form-group">
                                    <label className="form-label">
                                        Minutes
                                    </label>
                                    <input
                                        type="number"
                                        className="form-input"
                                        value={duration}
                                        onChange={(e) =>
                                            setDuration(e.target.value)
                                        }
                                        placeholder="30"
                                        min="1"
                                        autoFocus={mode === "manual"}
                                    />
                                </div>
                            )}

                            {session && session.audioData && audioUrl && (
                                <div className="form-group">
                                    <label className="form-label">
                                        Recorded Audio
                                    </label>
                                    <div className="existing-audio-controls">
                                        {!isPlaying ? (
                                            <button
                                                type="button"
                                                className="audio-button play"
                                                onClick={playAudio}
                                            >
                                                ▶️ Play Recording
                                            </button>
                                        ) : (
                                            <button
                                                type="button"
                                                className="audio-button stop"
                                                onClick={stopAudio}
                                            >
                                                ⏸️ Stop Playback
                                            </button>
                                        )}
                                    </div>
                                </div>
                            )}

                            <div className="modal-actions">
                                <button
                                    className="button button-secondary"
                                    onClick={onClose}
                                    disabled={isRecording}
                                >
                                    Cancel
                                </button>
                                {session && (
                                    <button
                                        className="button button-danger"
                                        onClick={handleDelete}
                                        disabled={isRecording}
                                    >
                                        Delete
                                    </button>
                                )}
                                <button
                                    className="button button-primary"
                                    onClick={handleSave}
                                    disabled={
                                        isRecording ||
                                        (mode === "manual" &&
                                            (!duration ||
                                                parseInt(duration) <= 0)) ||
                                        (mode === "record" &&
                                            recordingTime === 0)
                                    }
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            // Main App
            function App() {
                const [currentWeek, setCurrentWeek] = useState("");
                const [modalOpen, setModalOpen] = useState(false);
                const [modalDate, setModalDate] = useState("");
                const [modalSession, setModalSession] = useState(null);

                const { data: weekData, loading: weekLoading } =
                    useQuery(GET_CURRENT_WEEK);

                useEffect(() => {
                    if (weekData?.data?.currentWeekStart && !currentWeek) {
                        setCurrentWeek(weekData.data.currentWeekStart);
                    }
                }, [weekData, currentWeek]);

                const {
                    data: practiceData,
                    loading: practiceLoading,
                    refetch,
                } = useQuery(GET_PRACTICE_SESSIONS_BY_DAY, {
                    variables: { weekStart: currentWeek },
                    skip: !currentWeek,
                });

                const { data: weeklyData, refetch: refetchWeekly } = useQuery(
                    GET_WEEKLY_PRACTICE,
                    {
                        variables: { weekStart: currentWeek },
                        skip: !currentWeek,
                    },
                );

                const practiceByDay =
                    practiceData?.data?.practiceSessionsByDay || [];
                const weeklyTotal =
                    weeklyData?.data?.practiceSessionsForWeek?.totalMinutes ||
                    0;

                const handleDayClick = (date) => {
                    setModalDate(date);
                    setModalSession(null);
                    setModalOpen(true);
                };

                const handleSessionClick = (session, date, e) => {
                    e.stopPropagation();
                    setModalDate(date);
                    setModalSession(session);
                    setModalOpen(true);
                };

                const handleSave = () => {
                    refetch();
                    refetchWeekly();
                };

                if (weekLoading || practiceLoading) {
                    return <div className="loading">Loading...</div>;
                }

                return (
                    <div className="app">
                        <header className="header">
                            <h1 className="title">🗓️PracticeCal</h1>
                        </header>

                        <div className="week-nav">
                            <button
                                className="nav-button"
                                onClick={() =>
                                    setCurrentWeek(addWeeks(currentWeek, -1))
                                }
                            >
                                ‹
                            </button>
                            <div className="week-title">
                                {formatWeekRange(currentWeek)}
                            </div>
                            <button
                                className="nav-button"
                                onClick={() =>
                                    setCurrentWeek(addWeeks(currentWeek, 1))
                                }
                            >
                                ›
                            </button>
                        </div>

                        <div className="calendar">
                            <div className="calendar-row">
                                <div className="day-header">Sun</div>
                                <div className="day-header">Mon</div>
                                <div className="day-header">Tue</div>
                                <div className="day-header">Wed</div>
                                <div className="day-header">Thu</div>
                                <div className="day-header">Fri</div>
                                <div className="day-header">Sat</div>
                            </div>
                            <div className="calendar-row">
                                {practiceByDay.map((day) => (
                                    <div
                                        key={day.date}
                                        className={`day-cell ${
                                            day.totalMinutes > 0
                                                ? "has-practice"
                                                : ""
                                        } ${isToday(day.date) ? "today" : ""}`}
                                        onClick={() => handleDayClick(day.date)}
                                    >
                                        <div className="day-date">
                                            {formatDate(day.date)}
                                        </div>
                                        {day.totalMinutes > 0 && (
                                            <div className="day-total">
                                                {formatMinutes(
                                                    day.totalMinutes,
                                                )}
                                            </div>
                                        )}
                                        {day.sessions.map((session) => (
                                            <div
                                                key={session.id}
                                                className="session"
                                                onClick={(e) =>
                                                    handleSessionClick(
                                                        session,
                                                        day.date,
                                                        e,
                                                    )
                                                }
                                            >
                                                <div className="session-duration">
                                                    {formatMinutes(
                                                        session.durationMinutes,
                                                    )}
                                                </div>
                                                {session.audioData && (
                                                    <div className="session-audio-indicator">
                                                        🎙️
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="total-practice">
                            <div className="total-label">
                                Total Practice Time
                            </div>
                            <div className="total-time">
                                {weeklyTotal > 0
                                    ? formatMinutes(weeklyTotal)
                                    : "0m"}
                            </div>
                            <div className="total-subtitle">This week</div>
                        </div>

                        <Modal
                            isOpen={modalOpen}
                            onClose={() => setModalOpen(false)}
                            date={modalDate}
                            session={modalSession}
                            onSave={handleSave}
                        />
                    </div>
                );
            }

            ReactDOM.createRoot(document.getElementById("root")).render(
                <App />,
            );
        </script>
    </body>
</html>
